---
title: "Modint"
permalink: /posts/modint
writer: anko9801
layout: library
---

## 説明

## 計算量

## 実装

```cpp
using ll = long long;
using u64 = std::uint_fast64_t;

constexpr u64 Modulus = MOD;
class Modint {
public:
	u64 num = 0;
	constexpr Modint() noexcept {}
	constexpr Modint(const u64 x) noexcept : num(x % Modulus) {}
	inline constexpr operator ll() const noexcept { return num; }
	inline constexpr Modint &operator+=(const Modint rhs) noexcept { num += rhs.num; if (num >= Modulus) num -= Modulus; return *this; }
	inline constexpr Modint operator+(const Modint rhs) const noexcept { return Modint(*this) += rhs; }
	inline constexpr Modint &operator-=(const Modint rhs) noexcept { if (num < rhs.num) num += Modulus; num -= rhs.num; return *this; }
	inline constexpr Modint operator-(const Modint rhs) const noexcept { return Modint(*this) -= rhs; }
	inline constexpr Modint &operator*=(const Modint rhs) noexcept { num = num * rhs.num % Modulus; return *this; }
	inline constexpr Modint operator*(const Modint rhs) const noexcept { return Modint(*this) *= rhs; }
	inline constexpr Modint &operator/=(const Modint rhs) noexcept { return operator*=(rhs.inv()); }
	constexpr Modint operator/(const Modint rhs) const noexcept { return Modint(*this) /= rhs; }
	inline constexpr Modint& operator++() noexcept { if (num == Modulus - 1) num = 0; else num++; return *this; }
	inline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }
	inline constexpr Modint& operator--() noexcept { if (num == 0) num = Modulus - 1; else num--; return *this; }
	inline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }
	inline constexpr Modint operator-() noexcept { return Modint(0) -= *this; }
	template<class T> inline constexpr Modint &operator+=(T x) noexcept { return operator+=(Modint(x)); }
	template<class T> inline constexpr Modint &operator+(T x) noexcept { return Modint(*this) += x; }
	template<class T> inline constexpr Modint &operator-=(T x) noexcept { return operator-=(Modint(x)); }
	template<class T> inline constexpr Modint &operator-(T x) noexcept { return Modint(*this) -= x; }
	template<class T> inline constexpr Modint &operator*=(T x) noexcept { return operator*=(Modint(x)); }
	template<class T> inline constexpr Modint &operator*(T x) noexcept { return Modint(*this) *= x; }
	template<class T> inline constexpr Modint &operator/=(T x) noexcept { return operator/=(Modint(x)); }
	template<class T> inline constexpr Modint &operator/(T x) noexcept { return Modint(*this) /= x; }
	inline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, Modulus, x, y); return x; }
	static inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }
	inline constexpr Modint pow(ull x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }
	template<class T> constexpr Modint(T x) noexcept {
		using U = typename conditional<sizeof(T) >= 4, T, int>::type;
		U y = x; y %= U(Modulus); if(y < 0) y += Modulus; num = uint(y);
	}
};
std::istream& operator>>(std::istream& is, Modint& x){ ll a; cin >> a; x = a; return is; }
// inline constexpr Modint operator""_M(ull x) noexcept { return Modint(x); }
std::vector<Modint> fac(1, 1), inv(1, 1);
inline void reserve(ll a){
	if(fac.size() >= a) return;
	if(a < fac.size() * 2) a = fac.size() * 2;
	if(a >= Modulus) a = Modulus;
	while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));
	inv.resize(fac.size());
	inv.back() = fac.back().inv();
	for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;
}
inline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }
inline Modint perm(ll n, ll r){
	if(r < 0 || n < r) return 0;
	if(n >> 24){ Modint ans = 1; for(ll i = 0; i < r; i++) ans *= n--; return ans; }
	reserve(n + 1); return fac[n] * inv[n - r];
}
// 階乗やその逆元をメモ化すると速い
// modを取りたくないならnCk/2^Nをパスカルの三角形で作る
inline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }
inline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes
inline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }
```

## 使用例

```cpp
class runtime_modint {
  using u64 = std::uint_fast64_t;

  static u64 &mod() {
    static u64 mod_ = 0;
    return mod_;
  }

public:
  u64 a;

  runtime_modint(const u64 x = 0) : a(x % get_mod()) {}
  u64 &value() noexcept { return a; }
  const u64 &value() const noexcept { return a; }
  inline constexpr operator ll() const noexcept { return a; }
  runtime_modint operator+(const runtime_modint rhs) const {
    return runtime_modint(*this) += rhs;
  }
  runtime_modint operator-(const runtime_modint rhs) const {
    return runtime_modint(*this) -= rhs;
  }
  runtime_modint operator*(const runtime_modint rhs) const {
    return runtime_modint(*this) *= rhs;
  }
  runtime_modint operator/(const runtime_modint rhs) const {
    return runtime_modint(*this) /= rhs;
  }
  runtime_modint &operator+=(const runtime_modint rhs) {
    a += rhs.a;
    if (a >= get_mod()) {
      a -= get_mod();
    }
    return *this;
  }
  runtime_modint &operator-=(const runtime_modint rhs) {
    if (a < rhs.a) {
      a += get_mod();
    }
    a -= rhs.a;
    return *this;
  }
  runtime_modint &operator*=(const runtime_modint rhs) {
    a = a * rhs.a % get_mod();
    return *this;
  }
  runtime_modint &operator/=(runtime_modint rhs) {
    u64 exp = get_mod() - 2;
    while (exp) {
      if (exp % 2) {
        *this *= rhs;
      }
      rhs *= rhs;
      exp /= 2;
    }
    return *this;
  }

  template <class T> inline constexpr runtime_modint &operator+=(T x) noexcept {
    return operator+=(runtime_modint(x));
  }
  template <class T> inline constexpr runtime_modint &operator+(T x) noexcept {
    return runtime_modint(*this) += x;
  }
  template <class T> inline constexpr runtime_modint &operator-=(T x) noexcept {
    return operator-=(runtime_modint(x));
  }
  template <class T> inline constexpr runtime_modint &operator-(T x) noexcept {
    return runtime_modint(*this) -= x;
  }
  template <class T> inline constexpr runtime_modint &operator*=(T x) noexcept {
    return operator*=(runtime_modint(x));
  }
  template <class T> inline constexpr runtime_modint &operator*(T x) noexcept {
    return runtime_modint(*this) *= x;
  }
  template <class T> inline constexpr runtime_modint &operator/=(T x) noexcept {
    return operator/=(runtime_modint(x));
  }
  template <class T> inline constexpr runtime_modint &operator/(T x) noexcept {
    return runtime_modint(*this) /= x;
  }

  static void set_mod(const u64 x) { mod() = x; }
  static u64 get_mod() { return mod(); }
};

ll n, m;
bool used[100000];
vec<pair<ll, runtime_modint>> G[100000];

runtime_modint dfs(ll x) {
  used[x] = true;
  bool end = true;
  runtime_modint res = 1;
  each(p, G[x]) {
    if (used[p.fi] == true)
      continue;
    end = false;
    if (p.se != 0) {
      res *= p.se;
    } else {
      p.se = dfs(p.fi);
      // cout << x MM p.fi MM p.se << endl;
      res *= p.se;
    }
  }
  used[x] = false;
  return res + 1;
}
```